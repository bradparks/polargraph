#!/usr/bin/perl
# Translate the vectors from a PJL file into gcode for the polargraph.
# There is probably a better way to do this.
# origin is at l1=2032 l2=2032 
# separation between the two is 2.5m
use warnings;
use strict;
use Getopt::Long qw/:config no_ignore_case/;

my $usage = <<"";
$0: Plot a set of vectors on the polargraph.
Options:
    -H | --home       Send the set-home command in the gcode
    -w | --width N    Separation between the pulleys in mm
    -l | --length N   Length of the two strings at the home position in mm
    -f | --feed N     Feed rate for the motors in mm/sec
    -F | --transit N  Transit rate for the motors in mm/sec
    -n | --step N     Interpolation step size for straight lines in mm
    -M | --motors-on  Leave the motors on after the plot (default off)
    -r | --rotate     Rotate the PDF 90 degrees
    --offset x,y      Shift the origin to x,y in mm
    --scale N         Scale the plot by this factor
    --steps N         Adjust the steps/mm to deal with maljusted printers

my $width = 2501.9;
my $home_length = 2032.0;
my $default_feed = 2000;
my $transit_feed = 2500;
my $step_size = 40;
my $motor_on = 0;
my $send_home = 0;
my $offset_x = 0;
my $offset_y = 0;
my $steps_per_step = 1;
my $rotate = 0;

my $scale = 1;

my $total_dist = 0;
my $total_time = 0;

GetOptions(
	"H|home+"	=> \$send_home,
	"r|rotate+"	=> \$rotate,
	"w|width=f"	=> \$width,
	"l|length=f"	=> \$home_length,
	"f|feed=f"	=> \$default_feed,
	"F|transit=f"	=> \$transit_feed,
	"n|step=f"	=> \$step_size,
	"x|offset-x=f"	=> \$offset_x,
	"y|offset-y=f"	=> \$offset_y,
	"scale=f"	=> \$scale,
	"steps=f"	=> \$steps_per_step,
	"h|?|help"	=> sub { print $usage; exit 0; }
) or die $usage;

# assume the zero-zero point is in the center (width/2) and
# the triangles are right. length^2 = (width/2)^2 + height^2
my $height = $home_length*$home_length - $width*$width/4.0;
die "Width $width is too wide for length $home_length!\n"
	if $height <= 0;
$height = sqrt($height);
printf STDERR "Computed height: %0.2fmm\n", $height;
printf STDERR "0 0\n";
printf STDERR "%.2f %.2f\n", $width, 0;
printf STDERR "%.2f %.2f\n", $width, $height;
printf STDERR "%.2f %.2f\n", 0, $height;
printf STDERR "0 0\n\n";


print "M999\n"; # reset any error condition
print "G90\nG92 X0 Y0\n";
print "G92 X$home_length Y$home_length\n"
	if $send_home;


my @old;
my $old_file = $ARGV[0];

while(<>)
{
	if($ARGV ne $old_file)
	{
		$old_file = $ARGV;
		print "M72 P2\n";
		print "M71 (Marker Change)\n";
	}

	chomp;
	my @points = split /,/;

	for(my $i = 0 ; $i < @points ; $i+=2)
	{
		my ($x,$y) = @points[$i,$i+1];
		($x,$y) = ($width - $y,$x) if $rotate;
		my $feed = $default_feed;
		if ($x =~ s/^PU//)
		{
			$feed = $transit_feed;
			@old = ();
		}

		$x =~ s/^PD//;

		# 0.06 is something to do with HPGL weirdness
		# no clue what 23.55 means in this case
		$x = $x * $scale / 23.55 + $offset_x;
		$y = $y * $scale / 23.55 + $offset_y;

		# if the $x and $y are outside of our bounding box,
		# warn that this might not work
		if ($x < 0 || $x > $width || $y < 0 || $y > $height)
		{
			printf STDERR "!!! %.02f,%.02f out of bounds\n", $x, $y;
		}

		if (@old)
		{
			goxy_step(@old, $x,$y, $feed);
			my $dist = len(@old, $x, $y);
			$total_dist += $dist;
			$total_time += $dist / ($feed / 60.0);
		} else {
			goxy($x,$y, $feed);
		}
		@old = ($x,$y);
	}
}

sub len
{
	my ($x1,$y1,$x2,$y2) = @_;
	my $dx = $x2 - $x1;
	my $dy = $y2 - $y1;
	return sqrt($dx*$dx + $dy*$dy);
}


sub goxy_step
{
	my ($x0,$y0,$x1,$y1,$feed) = @_;

	# iterate from x0,y0 to x1,y1
	my $dx = $x1 - $x0;
	my $dy = $y1 - $y0;
	my $dist = sqrt($dx*$dx+$dy*$dy);

	my $steps = int($dist/$step_size);

	for(my $i = 0 ; $i < $steps ; $i++)
	{
		$x0 += $dx / $steps;
		$y0 += $dy / $steps;
		goxy($x0,$y0,$feed);
	}

	goxy($x1,$y1,$feed);
}


sub goxy
{
	# convert from pts to something
	my $x = shift;
	my $y = shift;
	my $feed = shift || 1000;

	my $l1 = sqrt($x*$x + $y*$y);
	my $l2 = sqrt(($width-$x)*($width-$x) + $y*$y);

	# fix for the makerbot software
	$l1 = ($l1 - $home_length) * $steps_per_step;
	$l2 = ($l2 - $home_length) * $steps_per_step;

	printf STDERR "%.3f %.3f -> %.3f %.3f\n", $x, $y, $l1, $l2;
	printf "G1 X%.3f Y%.3f F%d\n", $l1, $l2, $feed;
}

# Send the marker back to home at the high speed
printf "G1 X%.3f Y%.3f F%d\n", 0, 0, $transit_feed;

# Turn off the motors if requested
print "M18 X Y\n" unless $motor_on;
print "M72 P1\n";
print "M137\n";

# Report some stats
printf STDERR "Total %.02fm %.0fm%02.0fs\n",
	$total_dist / 1000.0,
	$total_time / 60,
	$total_time % 60;


