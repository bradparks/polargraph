#!/usr/bin/perl
# Translate the vectors from a PJL file into gcode for the polargraph.
# There is probably a better way to do this.
# origin is at l1=2032 l2=2032 
# separation between the two is 2.5m
use warnings;
use strict;
use Getopt::Long qw/:config no_ignore_case/;

my $usage = <<"";
$0: Plot a set of vectors on the polargraph.
Options:
    -H | --home       Send the set-home command in the gcode
    -w | --width N    Separation between the pulleys in mm
    -l | --length N   Length of the two strings at the home position in mm
    -f | --feed N     Feed rate for the motors in mm/sec
    -F | --transit N  Transit rate for the motors in mm/sec
    -n | --step N     Interpolation step size for straight lines in mm
    -M | --motors-on  Leave the motors on after the plot (default off)
    --offset x,y      Shift the origin to x,y in mm
    --scale N         Scale the plot by this factor
    --steps N         Adjust the steps/mm to deal with maljusted printers

my $width = 2501.9;
my $home_length = 2032.0;
my $default_feed = 2000;
my $transit_feed = 2500;
my $step_size = 40;
my $motor_on = 0;
my $send_home = 0;
my $offset_x = 0;
my $offset_y = 0;
my $steps_per_step = 1;

my $scale = 1;

GetOptions(
	"H|home+"	=> \$send_home,
	"w|width=f"	=> \$width,
	"l|length=f"	=> \$home_length,
	"f|feed=f"	=> \$default_feed,
	"F|transit=f"	=> \$transit_feed,
	"n|step=f"	=> \$step_size,
	"x|offset-x=f"	=> \$offset_x,
	"y|offset-y=f"	=> \$offset_y,
	"scale=f"	=> \$scale,
	"steps=f"	=> \$steps_per_step,
	"h|?|help"	=> sub { print $usage; exit 0; }
) or die $usage;

print "G90\nG92 X0 Y0\n";
print "G92 X$home_length Y$home_length\n"
	if $send_home;


my @old;
my $old_file = $ARGV[0];

while(<>)
{
	if($ARGV ne $old_file)
	{
		$old_file = $ARGV;
		print "M72 P2\n";
		print "M71 (Marker Change)\n";
	}

	chomp;
	my @points = split /,/;

	for(my $i = 0 ; $i < @points ; $i+=2)
	{
		my ($x,$y) = @points[$i,$i+1];
		my $feed = $default_feed;
		if ($x =~ s/^PU//)
		{
			$feed = $transit_feed;
			@old = ();
		}

		$x =~ s/^PD//;

		# 0.06 is something to do with HPGL weirdness
		# no clue what 23.55 means in this case
		$x = $x * $scale / 23.55 + $offset_x;
		$y = $y * $scale / 23.55 + $offset_y;
	

		if (@old)
		{
			goxy_step(@old, $x,$y, $feed);
		} else {
			goxy($x,$y, $feed);
		}
		@old = ($x,$y);
	}
}


sub goxy_step
{
	my ($x0,$y0,$x1,$y1,$feed) = @_;

	# iterate from x0,y0 to x1,y1
	my $dx = $x1 - $x0;
	my $dy = $y1 - $y0;
	my $dist = sqrt($dx*$dx+$dy*$dy);

	my $steps = int($dist/$step_size);

	for(my $i = 0 ; $i < $steps ; $i++)
	{
		$x0 += $dx / $steps;
		$y0 += $dy / $steps;
		goxy($x0,$y0,$feed);
	}

	goxy($x1,$y1,$feed);
}


sub goxy
{
	# convert from pts to something
	my $x = shift;
	my $y = shift;
	my $feed = shift || 1000;

	my $l1 = sqrt($x*$x + $y*$y);
	my $l2 = sqrt(($width-$x)*($width-$x) + $y*$y);

	# fix for the makerbot software
	$l1 = ($l1 - $home_length) * $steps_per_step;
	$l2 = ($l2 - $home_length) * $steps_per_step;

	printf STDERR "%.3f %.3f -> %.3f %.3f\n", $x, $y, $l1, $l2;
	printf "G1 X%.3f Y%.3f F%d\n", $l1, $l2, $feed;
}

# Turn off the motors if requested
print "M18 X Y\n" unless $motor_on;
print "M72 P1\n";
print "M137\n";
